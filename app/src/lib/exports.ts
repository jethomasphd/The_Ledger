/**
 * Export System
 *
 * Produces three artifacts:
 * 1. brief.md — Markdown brief with receipt tokens
 * 2. brief.docx — Word document version
 * 3. provenance.json — Full provenance log
 */

import { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType } from 'docx';
import { saveAs } from 'file-saver';
import type { Mission, Action, ReceiptToken } from './types';
import { formatTokenAsMarkdown } from './receipt-tokens';
import { provenanceToJson, markExported } from './provenance';

// ─── Markdown Brief ─────────────────────────────────────

export function generateBriefMarkdown(mission: Mission): string {
  const { query, provenance, selectedBills, actions, votes } = mission;
  const lines: string[] = [];

  lines.push('# The Ledger — Mission Brief');
  lines.push('');
  lines.push(`**Query:** ${query}`);
  lines.push(`**Date:** ${new Date().toISOString().split('T')[0]}`);
  lines.push(`**Session:** ${provenance.sessionId}`);
  lines.push('');
  lines.push('---');
  lines.push('');

  // Retrieval strategies used
  lines.push('## Retrieval Strategies');
  lines.push('');
  for (const strat of provenance.strategies) {
    lines.push(`- **${strat.label}** (${strat.source}): ${strat.resultCount} results — ${strat.success ? 'success' : 'failed'}`);
  }
  lines.push('');

  // Selected bills
  lines.push('## Selected Bills');
  lines.push('');
  for (const bill of selectedBills) {
    lines.push(`### ${bill.chamber} ${bill.number}: ${bill.title}`);
    lines.push('');
    if (bill.sponsor) lines.push(`**Sponsor:** ${bill.sponsor}`);
    if (bill.introducedDate) lines.push(`**Introduced:** ${bill.introducedDate}`);
    if (bill.policyArea) lines.push(`**Policy Area:** ${bill.policyArea}`);
    if (bill.latestActionText) {
      lines.push(`**Latest Action:** ${bill.latestActionText} (${bill.latestActionDate})`);
    }
    lines.push('');
    lines.push(`Receipt: ${formatReceiptInline(bill.receiptToken, provenance.citationsMap)}`);
    lines.push(`Source: ${bill.congressGovUrl}`);
    lines.push('');
  }

  // Actions (3-3-3: max 3 per bill by default)
  const billActions = groupByBill(actions);
  if (Object.keys(billActions).length > 0) {
    lines.push('## Key Actions');
    lines.push('');
    for (const [billToken, acts] of Object.entries(billActions)) {
      lines.push(`### ${billToken}`);
      lines.push('');
      for (const action of acts.slice(0, 3)) {
        lines.push(`- **${action.actionDate}**: ${action.text}`);
        lines.push(`  Receipt: ${formatReceiptInline(action.receiptToken, provenance.citationsMap)}`);
      }
      if (acts.length > 3) {
        lines.push(`  *(${acts.length - 3} additional actions not shown — expand in app)*`);
      }
      lines.push('');
    }
  }

  // Votes (3-3-3: max 3 by default)
  if (votes.length > 0) {
    lines.push('## Roll Call Votes');
    lines.push('');
    for (const vote of votes.slice(0, 3)) {
      lines.push(`### ${vote.chamber} Roll ${vote.rollNumber} (${vote.date})`);
      lines.push('');
      lines.push(`**Question:** ${vote.question}`);
      lines.push(`**Result:** ${vote.result}`);
      lines.push(`**Tally:** Yea ${vote.yeas} / Nay ${vote.nays} / Present ${vote.present} / Not Voting ${vote.notVoting}`);
      lines.push(`Receipt: ${formatReceiptInline(vote.receiptToken, provenance.citationsMap)}`);
      lines.push(`Source: ${vote.sourceUrl}`);
      lines.push('');
    }
    if (votes.length > 3) {
      lines.push(`*(${votes.length - 3} additional votes not shown)*`);
      lines.push('');
    }
  }

  // Provenance footer
  lines.push('---');
  lines.push('');
  lines.push('## Provenance');
  lines.push('');
  lines.push(`This brief was generated by **The Ledger** on ${new Date().toISOString()}.`);
  lines.push('Every claim above is tethered to a primary source via Receipt Tokens.');
  lines.push('See the accompanying `provenance.json` for the full chain of custody.');
  lines.push('');
  lines.push('**Evidence Classification:**');
  lines.push('- **WITNESSED**: Directly observed in primary source data');
  lines.push('- **INFERENCE**: Derived by reasoning over witnessed data');
  lines.push('');

  return lines.join('\n');
}

function formatReceiptInline(
  token: string,
  citationsMap: Record<string, ReceiptToken>,
): string {
  const receipt = citationsMap[token];
  if (receipt) {
    return formatTokenAsMarkdown(receipt);
  }
  return `\`${token}\``;
}

function groupByBill(actions: Action[]): Record<string, Action[]> {
  const groups: Record<string, Action[]> = {};
  for (const action of actions) {
    if (!groups[action.billToken]) {
      groups[action.billToken] = [];
    }
    groups[action.billToken].push(action);
  }
  return groups;
}

// ─── DOCX Brief ─────────────────────────────────────────

export async function generateBriefDocx(mission: Mission): Promise<Blob> {
  const { query, provenance, selectedBills, votes } = mission;

  const children: Paragraph[] = [];

  children.push(
    new Paragraph({
      text: 'The Ledger — Mission Brief',
      heading: HeadingLevel.TITLE,
      alignment: AlignmentType.CENTER,
    }),
  );

  children.push(new Paragraph({ text: '' }));
  children.push(
    new Paragraph({
      children: [
        new TextRun({ text: 'Query: ', bold: true }),
        new TextRun({ text: query }),
      ],
    }),
  );
  children.push(
    new Paragraph({
      children: [
        new TextRun({ text: 'Date: ', bold: true }),
        new TextRun({ text: new Date().toISOString().split('T')[0] }),
      ],
    }),
  );
  children.push(
    new Paragraph({
      children: [
        new TextRun({ text: 'Session: ', bold: true }),
        new TextRun({ text: provenance.sessionId }),
      ],
    }),
  );

  // Bills
  children.push(new Paragraph({ text: '' }));
  children.push(
    new Paragraph({
      text: 'Selected Bills',
      heading: HeadingLevel.HEADING_1,
    }),
  );

  for (const bill of selectedBills) {
    children.push(
      new Paragraph({
        text: `${bill.chamber} ${bill.number}: ${bill.title}`,
        heading: HeadingLevel.HEADING_2,
      }),
    );
    if (bill.sponsor) {
      children.push(
        new Paragraph({
          children: [
            new TextRun({ text: 'Sponsor: ', bold: true }),
            new TextRun({ text: bill.sponsor }),
          ],
        }),
      );
    }
    children.push(
      new Paragraph({
        children: [
          new TextRun({ text: 'Receipt: ', bold: true }),
          new TextRun({ text: bill.receiptToken, color: '4ade80' }),
        ],
      }),
    );
    children.push(
      new Paragraph({
        children: [
          new TextRun({ text: 'Source: ', bold: true }),
          new TextRun({ text: bill.congressGovUrl }),
        ],
      }),
    );
  }

  // Votes
  if (votes.length > 0) {
    children.push(new Paragraph({ text: '' }));
    children.push(
      new Paragraph({
        text: 'Roll Call Votes',
        heading: HeadingLevel.HEADING_1,
      }),
    );

    for (const vote of votes.slice(0, 3)) {
      children.push(
        new Paragraph({
          text: `${vote.chamber} Roll ${vote.rollNumber} (${vote.date})`,
          heading: HeadingLevel.HEADING_2,
        }),
      );
      children.push(
        new Paragraph({
          children: [
            new TextRun({ text: `${vote.question} — ${vote.result}` }),
          ],
        }),
      );
      children.push(
        new Paragraph({
          children: [
            new TextRun({ text: `Yea ${vote.yeas} / Nay ${vote.nays} / Present ${vote.present} / Not Voting ${vote.notVoting}` }),
          ],
        }),
      );
      children.push(
        new Paragraph({
          children: [
            new TextRun({ text: 'Receipt: ', bold: true }),
            new TextRun({ text: vote.receiptToken, color: '4ade80' }),
          ],
        }),
      );
    }
  }

  // Provenance footer
  children.push(new Paragraph({ text: '' }));
  children.push(
    new Paragraph({
      text: 'Provenance',
      heading: HeadingLevel.HEADING_1,
    }),
  );
  children.push(
    new Paragraph({
      text: `Generated by The Ledger on ${new Date().toISOString()}. Every claim is tethered to a primary source via Receipt Tokens. See provenance.json for the full chain of custody.`,
    }),
  );

  const doc = new Document({
    sections: [{ children }],
  });

  return await Packer.toBlob(doc);
}

// ─── Download Helpers ───────────────────────────────────

export function downloadMarkdown(mission: Mission): void {
  const md = generateBriefMarkdown(mission);
  const blob = new Blob([md], { type: 'text/markdown;charset=utf-8' });
  saveAs(blob, `ledger-brief-${mission.provenance.sessionId}.md`);
}

export async function downloadDocx(mission: Mission): Promise<void> {
  const blob = await generateBriefDocx(mission);
  saveAs(blob, `ledger-brief-${mission.provenance.sessionId}.docx`);
}

export function downloadProvenance(mission: Mission): void {
  const log = markExported(mission.provenance);
  const json = provenanceToJson(log);
  const blob = new Blob([json], { type: 'application/json;charset=utf-8' });
  saveAs(blob, `ledger-provenance-${mission.provenance.sessionId}.json`);
}
